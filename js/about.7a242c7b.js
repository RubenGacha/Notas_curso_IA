"use strict";(self["webpackChunkplantilla"]=self["webpackChunkplantilla"]||[]).push([[443],{8260:function(e,a,o){o.r(a),o.d(a,{default:function(){return p}});var i=o(6252);const n={class:"about"},s=(0,i._)("h1",null,"This is an about page",-1),r=(0,i._)("code",{class:"javascript"},"const s = new Date().toString()",-1),t=[r];function l(e,a){const o=(0,i.up)("math-jax"),r=(0,i.Q2)("highlightjs");return(0,i.wg)(),(0,i.iD)("div",n,[s,(0,i.wy)(((0,i.wg)(),(0,i.iD)("pre",null,t)),[[r]]),(0,i.Wm)(o,{latex:"\\prec"})])}var c=o(3744);const d={},u=(0,c.Z)(d,[["render",l]]);var p=u},3102:function(e,a,o){o.r(a),o.d(a,{default:function(){return u}});var i=o(6252);const n={id:"cuerpo"},s=(0,i.uE)("<h1>Busqueda Grafos</h1><h2>Planificacion</h2><h3>Busqueda no informada</h3><ul><li>Busqueda en Anchura</li><li>Busqueda en Anchura de Costo Uniforme</li><li>Busqueda en Profundidad</li><li>Busqueda en profundidad limitada</li><li>Busqueda en profundidad Iterativa</li><li>Busqueda bidireccional</li><li>Busqueda en Grafos</li></ul><h3>Busqueda informada</h3><ul><li>heuristicas</li><li>Busqueda voraz primero el mejor</li><li>Busquedas A* y AO * (estrella)</li><li>Busqueda de Ascension de Colinas</li><li>Busqueda Tabu</li><li>Busqueda de Temple Simulado</li><li>Busqueda de Haz local</li><li>Algoritmos geneticos</li><li>Busqueda Online</li></ul><h3>Satisfaccion de restricciones</h3><ul><li>Problemas de satisfaccion de restricciones</li><li>Busqueda de vuelta atras</li><li>Comprobacion hacia Delante</li><li>Propagacion de restricciones</li><li>Salto Atras Dirigido por conflictos</li><li>Busqueda Local: minimos-conflictos</li><li>Acondicionamiento del corte</li></ul><h2>Juegos</h2><ul><li>Teoria de juegos</li><li>minimax</li><li>poda Alfa-Beta</li><li>Funcion de evaluacion</li><li>Corte de busqueda: efecto horizonte</li><li>posibilidad:minimaxEsperado</li></ul><h2>Utilidad y toma de decisiones</h2><ul><li>Teoria de la utilidad: funcion de utilidad</li><li>Redes de decision</li><li>Valor de la informacion</li><li>Iteracion de Valores</li><li>Iteracion de Politicas</li><li>Proceso de Desicion de markov(MDP)</li><li>MDP parcialmente Observable (POMDP)</li><li>Red bayesiana Dinamica</li><li>Teoria de Juegos: Equilibrios y Mecanismos</li></ul><h2>Aprendizaje por refuerzo</h2><ul><li>Aprendizaje por refuerzo pasivo</li><li>Aprendizaje por refuerzo activo</li><li>Q-learning</li><li>Exploracion y Exploracion</li><li>Busqueda de la politica</li></ul>",14),r=[s];function t(e,a){return(0,i.wg)(),(0,i.iD)("div",n,r)}var l=o(3744);const c={},d=(0,l.Z)(c,[["render",t]]);var u=d},1642:function(e,a,o){o.r(a),o.d(a,{default:function(){return k}});var i=o(6252),n=o(3227);const s={id:"cuerpo"},r=(0,i.uE)('<h1>Agentes Inteligentes</h1><p>Los agentes Inteligentes son entes que logran percibir su entorno mediante sensores y actua sobre el mismo mediante actuadores.</p><table class="table table-dark table-striped table-hover"><tr><th scope="col"></th><th scope="col">Sensores</th><th scope="col">Actuadores</th></tr><tr><td scope="row">Humanos</td><td scope="row">Ojos, Oidos, Nariz, Boca, Piel </td><td scope="row">Manos, Pies, Cuerdas Vocales </td></tr><tr><td scope="row">Robots</td><td scope="row">Camaras, Infrarrojos, Laseres, Sonares, Sensores de presion</td><td scope="row">Motores, Brazos mecanicos, Pinzas, Altavoces.</td></tr><tr><td scope="row">Software</td><td scope="row">Pulsaciones de teclado, contenido de archivos, datos de red recibidos,etc. </td><td scope="row">pantallas, archivos de salida, Datos de red enviados, etc</td></tr></table><h2>Percepcion</h2><p>la percepcion es la capacidad de recibir informacion del entorno, con esto el agente puede tomar acciones en cualquier instante, aunque esto dependera de la secuencia de percepciones observada hasta ese momento.</p><p>para aclarar la secuencia de percepciones son la historia completa de los datos que ha percibido el agente durante un tiempo. se guardan en una memoria.</p><img src="'+n+'" alt="Forma en que funciona un agente"><h2>Funcion de Agente</h2><p>Se encarga de elegir una accion a partir de una secuencia de percepciones que se pueden visualizar en una tabla, en la que se puede encontrar las diferentes percepciones junto a la accion a realizar, al mismo tiempo se tiene una combinacion de las posibles percepciones que se tengan.</p><p>El caso ideal es que se tenga una accion para cada conjunto de percepciones que pueda tener nuestro agente. </p><h2>Medidas de Rendimiento</h2><dl><dt>Perfeccion</dt><dd>Si el agente conoce todos los resultados reales de sus acciones y puede actuar siempre de la mejor forma posible (omnisciencia). Maximiza el rendimiento real. nota: &quot;En el mundo real, es imposible&quot;</dd><dt>Racionalidad</dt><dd>Para cada secuencia de percepciones posibles, se selecciona la accion que supuestamente maximiza el rendimiento esperado.</dd></dl><h2>Aprendizaje</h2><p>Debido a que un agente no puede ser omnisciente, se debe percibir y aprender para poder maximizar el rendimiento en otras palabras debe tener una memoria, para esto debe explorar en busqueda de recopilacion de informacion, realizando acciones con la intencion de modificar percepciones futuras y memorizando el resultado </p><h2>Autonomia</h2><p>Un agente racional debe poder aprender todo lo que pueda para compensar la falta de conocimiento que posee a priori. Si no posee ningun conocimiento inicial, debe actuar de forma aleatoria.</p><p>A un agente racional hay que dotarlo de un conocimiento inicial y las capacidades de explorar y aprender</p><h2>Entorno de trabajo</h2><p>El entorno de trabajo son problemas del mundo real para los que los agentes racionales son las soluciones. este entorno de trabajo esta compuesto por cuatro componentes que son rendimiento, entorno, actuadores y sensores. estos cuatro componentes forman la palabra <em class="enfasis">REAS</em> que es la inicial de cada palabra.</p><p>El siguiente es un ejemplo de entorno de trabajo de un taxista.</p><ul><li><em>Entorno de trabajo</em> taxista</li><li><em>Rendimiento</em> seguro, rapido, legal, confortables</li><li><em>Entorno: </em> carreteras , trafico, peatones, clientes</li><li><em>Actuadores: </em> direccion, acelerador, freno, claxon.</li><li><em>Sensores: </em> Camaras, velocimetro, sensores termicos.</li></ul><h2>Propiedades</h2><p>los entornos de trabajo tienen una serie de propiedades las cuales se pueden adaptar a un algoritmo o a otro </p><dl><dt>Total o Parcialmente observable</dt><dd>Se refiere al nivel que se logra percibir del entorno ejemplo en un juego de ajedrez seria total, mientras en un juego de cartas seria parcial ya que no puede conocer las cartas que tiene el oponente. </dd><dt>Agente Individual o Multiagente</dt><dd>Se refiere a la cantidad de agentes que se involucran en el entorno, estos pueden comunicarse, cooperar o competir entre ellos. esto depende del entorno ejemplo un juego de monopolio todos compiten entre ellos pero pueden negociar y buscar un mayor beneficio.</dd><dt>Determinista o Estocastico</dt><dd>Se trata en que sucede cuando se realiza una determinada accion, cuando no depende de algo esterno y siempre la misma accion genera el mismo resultado se llama <em>determinista</em>, pero si depende de algo mas y no se tiene sertesa por ende se deja en manos de la probabilidad se llama <em>estocastico</em></dd><dt>Episodico o Secuencial</dt><dd>Se trata en que afecta las acciones tomadas con la siguientes acciones si no se genera una afectacion se llama <em>episodico</em> mientras si se genera una afectacion a la siguiente accion se llama <em>secuencial</em></dd><dt>Estatico o Dinamico</dt><dd>Se trata si el entorno cambia mientras el agente procesa la accion a ejecutar. cuando cambia se llama <em>dinamico</em> mientras si se mantiene se le denomina <em>estatico</em></dd><dt>Discreto o Continuo</dt><dd>hace referencia al tipo de dato que maneja el agente, el <em>discreto</em> indica que tienen valores enteros, mientras que los <em>continuos</em> hacen referencia a numeros reales.</dd><dt>Conocido o Desconocido</dt><dd>hace referencia a las leyes que se aplican en el entorno cuando se conoce se llama <em>conocido</em> mientras si no las conocen se llama <em>desconocido</em></dd></dl><h2>Tipos de Agentes</h2><p>Inicialmente para conocer los tipos de agente debemos conocer cual es el agente ideal el cual seria el agente tabla este conoce todas las acciones y las percepciones, teniendolas almacenadas en una tabla. lo siguiente seria el seudocodigo</p>',26),t=(0,i.uE)('<code class="plaintext"><em class="clave">funcion</em> <em class="cambiar">AGENTE_TABLA</em>(percepcion) <em class="clave">devuelve</em> accion\r\n    <em class="clave">datos</em>: \r\n        percepciones    <em class="comentario">#secuencia, inicialmente vacia.</em>\r\n        acciones        <em class="comentario">#tabla indexada por percepciones totalmente especificada.</em>\r\n    percepciones.agregar(percepcion)\r\n    accion=acciones.buscar(percepciones)\r\n    <em class="clave">devolver</em> accion\r\n    </code>',1),l=[t],c=(0,i._)("code",{class:"python"},"\r\n\"\"\"\r\naqui se encuentra la tabla donde van todas las acciones posibles.\r\naunque como se puede ver es muy dificil tener una tabla con todas las acciones,\r\nya que se debe validar cualquier conbinacion posible.\r\n\r\npor ejemplo que ingresen un codigo antes de una moneda o que ingresen mas de una moneda. \r\nel problema es exponencial a medida que se permitan mas percepciones,\r\nmas conbinaciones posibles existen.\r\n\"\"\"\r\n\r\n#-------------------------tabla---------------------------------\r\nACCIONES = {\r\n    'moneda': 'pedir-codigo',\r\n    'moneda,a1': 'servir-bebida1',\r\n    'moneda,a2': 'servir-bebida2',\r\n    'moneda,a3': 'servir-bebida3',\r\n    'moneda,a1,moneda': 'pedir-codigo',\r\n    'moneda,a2,moneda': 'pedir-codigo',\r\n    'moneda,a3,moneda': 'pedir-codigo',\r\n    'moneda,a1,moneda,a1': 'servir-bebida1',\r\n    'moneda,a1,moneda,a2': 'servir-bebida2',\r\n    'moneda,a1,moneda,a3': 'servir-bebida3',\r\n    'moneda,a2,moneda,a1': 'servir-bebida1',\r\n    'moneda,a2,moneda,a2': 'servir-bebida2',\r\n    'moneda,a2,moneda,a3': 'servir-bebida3',\r\n    'moneda,a3,moneda,a1': 'servir-bebida1',\r\n    'moneda,a3,moneda,a2': 'servir-bebida2',\r\n    'moneda,a3,moneda,a3': 'servir-bebida3',\r\n}\r\n\r\n#--------------------------------agente-----------------------------\r\nclass AgenteTabla:\r\n    \"\"\"Agente racional de tipo tabla\"\"\"\r\n\r\n    def __init__(self, acciones) -> None:\r\n        self.acciones = acciones\r\n        self.percepciones = \"\"\r\n\r\n    def actuar(self, percepcion, accion_basica=''):\r\n        \"\"\"Actua segun la percepcion, devolviendo accion\"\"\"\r\n        if not percepcion:\r\n            return accion_basica\r\n\r\n        if len(self.percepciones) != 0:\r\n            self.percepciones += \",\"\r\n\r\n        self.percepciones += percepcion\r\n\r\n        if self.percepciones in self.acciones.keys():\r\n            return self.acciones[self.percepciones]\r\n        else:\r\n            self.percepciones = ''\r\n            return accion_basica\r\n\r\n#-------------------- uso del agente ----------------------\r\n\r\nprint(\"---Agente tabla: Maquina Expendedora --\")\r\n\r\nexpendedora = AgenteTabla(ACCIONES)\r\n\r\npercepcion = input(\"Indicar Percepcion: \")\r\nwhile percepcion:\r\n    accion = expendedora.actuar(percepcion, 'reiniciarse')\r\n    print(accion)\r\n    percepcion = input(\"Indicar Percepcion: \")\r\n\r\n    ",-1),d=[c],u=(0,i._)("p",null,"teniendo el seudocodigo presente los siguientes son los tipos de agente.",-1),p=(0,i._)("h3",null,"Agentes Reactivos",-1),m=(0,i._)("p",null,"son los que actuan segun percepciones sin considerar las consecuencias de sus actos, es decir, no le importa que suceda en el entorno.",-1),b=(0,i._)("h4",null,"Agentes Reactivos Simple",-1),g=(0,i._)("p",null,"Solo tiene en cuenta la percepcion actual, no posee una histora de percepciones (actos reflejo) usa reglas condicion-accion (si-entonces) en vez de una tabla",-1),f=(0,i.uE)('<code class="plaintext"><em class="clave">funcion</em> <em class="cambiar">AGENTE_REACTIVO_SIMPLE</em>(percepcion) <em class="clave">devuelve</em> accion\r\n    <em class="clave">datos</em>: reglas    <em class="comentario">#conjunto de reglas si - entonces</em>\r\n    estado = <em class="clave">INTERPRETAR_ENTRADA</em>(percepcion)\r\n    regla=reglas.buscar(estado)\r\n    accion=regla.accion\r\n    <em class="clave">devolver</em> accion\r\n    </code>',1),h=[f],v=(0,i._)("code",{class:"python"},"\r\n\r\n#-------------------------reglas---------------------------------\r\nREGLAS = {\r\n    'moneda': 'pedir-codigo',\r\n    'a1': 'servir-bebida1',\r\n    'a2': 'servir-bebida2',\r\n    'a3': 'servir-bebida3',\r\n}\r\n\r\n#-------------------------agente---------------------------------\r\nclass AgenteReactivoSimple:\r\n    \"\"\"Agente racional de tipo Reactivo Simple\"\"\"\r\n\r\n    def __init__(self, reglas) -> None:\r\n        self.reglas = reglas\r\n\r\n    def actuar(self, percepcion, accion_basica=''):\r\n        \"\"\"Actua segun la percepcion, devolviendo accion\"\"\"\r\n        if not percepcion:\r\n            return accion_basica\r\n\r\n        if percepcion in self.reglas.keys():\r\n            return self.reglas[percepcion]\r\n        else:\r\n            return accion_basica\r\n\r\n#-------------------------uso---------------------------------\r\nprint(\"---Agente Reactivo Simple: Maquina Expendedora --\")\r\n\r\nexpendedora = AgenteReactivoSimple(REGLAS)\r\n\r\npercepcion = input(\"Indicar Percepcion: \")\r\nwhile percepcion:\r\n    accion = expendedora.actuar(percepcion, 'reiniciarse')\r\n    print(accion)\r\n    percepcion = input(\"Indicar Percepcion: \")\r\n\r\n    ",-1),q=[v],w=(0,i._)("h4",null,"Agentes Basado en Modelos",-1),A=(0,i._)("p",null,"almacena informacion de la parte del mundo que ha visitado (memoria). mantiene un estado interno y un modelo del mundo segun secuencia de percepciones",-1),y=(0,i.uE)('<code class="plaintext"><em class="clave">funcion</em> <em class="cambiar">AGENTE_BASADO_MODELOS</em>(percepcion) <em class="clave">devuelve</em> accion\r\n    <em class="clave">datos</em>:\r\n        estado    <em class="comentario">#Descripcion actual del mundo.</em>\r\n        modelo    <em class="comentario">#Dado estado y accion, devuelve nuevo estado.</em>\r\n        reglas    <em class="comentario">#Conjunto de reglas si - entonces</em>\r\n        accion    <em class="comentario">#Ultima accion realizara (ninguna inicialmente)</em>\r\n    estado = <em class="clave">ACTUALIZAR_ESTADO</em>(estado, accion, percepcion, modelo)\r\n    regla=reglas.buscar(estado)\r\n    accion=regla.accion\r\n    <em class="clave">devolver</em> accion\r\n    </code>',1),j=[y],E=(0,i._)("code",{class:"python"},"\r\n#Estados: sin-moneda, con-moneda,a1-servida,a2-servida,a3-servida\r\n#Acciones: pedir-moneda, pedir-codigo,esperar.\r\n#Percepciones: moneda,a1,a2,a3,servida.\r\n\r\n\r\n\r\nREGLAS = {\r\n    'sin-moneda':'pedir-moneda',\r\n    'con-moneda':'pedir-codigo',\r\n    'a1-servida':'esperar',\r\n    'a2-servida':'esperar',\r\n    'a3-servida':'esperar'\r\n}\r\n#el modelo hace el cambio de estado pasando por un estado inicial, realizando la accion de ese estado \r\n#y esperando a que la percepcion esperada para ese estado nos permite cambiar al siguiente estado.\r\nMODELO ={\r\n    ('sin-moneda','pedir-moneda','moneda'):'con-moneda',\r\n    ('con-moneda','pedir-codigo','a1'):'a1-servida',\r\n    ('con-moneda','pedir-codigo','a2'):'a2-servida',\r\n    ('con-moneda','pedir-codigo','a3'):'a3-servida',\r\n    ('a1-servida','esperar','servida'):'sin-moneda',\r\n    ('a2-servida','esperar','servida'):'sin-moneda',\r\n    ('a3-servida','esperar','servida'):'sin-moneda',\r\n}\r\nclass AgenteReactivoBasadoModelo:\r\n    \"\"\"Agente racional de tipo Reactivo basado en Modelo.\"\"\"\r\n\r\n    def __init__(self, modelo, reglas,estado_inicial='',accion_inicial='') -> None:\r\n        self.modelo = modelo\r\n        self.reglas = reglas\r\n        self.estado_inicial = estado_inicial\r\n        self.accion_inicial = accion_inicial\r\n        self.accion=None\r\n        self.estado=self.estado_inicial\r\n        self.ult_accion=self.accion_inicial\r\n        \r\n\r\n    def actuar(self, percepcion):\r\n        \"\"\"Actua segun la percepcion, devolviendo accion\"\"\"\r\n        if not percepcion:\r\n            return self.accion_inicial\r\n\r\n        clave=(self.estado,self.ult_accion,percepcion)\r\n        if clave not in self.modelo.keys():\r\n            self.estado=self.estado_inicial\r\n            self.accion=None\r\n            self.ult_accion=self.accion_inicial\r\n            return self.accion_inicial \r\n        else:\r\n            self.estado=self.modelo[clave]\r\n            if self.estado not in self.reglas.keys():\r\n                self.accion=None\r\n                self.estado=self.estado_inicial\r\n                self.ult_accion=self.accion_inicial\r\n                return self.accion_inicial\r\n            else:\r\n                accion=self.reglas[self.estado]\r\n                self.ult_accion=accion\r\n                return accion\r\n\r\n\r\nprint(\"---Agente Reactivo Basado en Modelos: Maquina Expendedora --\")\r\n\r\nexpendedora = AgenteReactivoBasadoModelo(MODELO,REGLAS,'sin-moneda','pedir-moneda')\r\n\r\npercepcion = input(\"Indicar Percepcion: \")\r\nwhile percepcion:\r\n    accion = expendedora.actuar(percepcion)\r\n    print(accion)\r\n    percepcion = input(\"Indicar Percepcion: \")\r\n\r\n",-1),S=[E],P=(0,i._)("h3",null,"Agentes que planifican",-1),x=(0,i._)("p",null,"Son los agentes que piensa en las consecuencias de sus actos (realiza simulaciones), es decir, segun como podria ser el entorno tras sus acciones",-1),D=(0,i._)("h4",null,"Agentes basados en Objetivos",-1),z=(0,i._)("p",null,"Aparte del estado interno y del modelo del mundo, el agente escoge la accion que le permita alcanzar un objetivo",-1),C=(0,i._)("h4",null,"Agentes basados en Utilidad",-1),_=(0,i._)("p",null,"Cuando existen varias formas de lograr un objetivo, o cuando existen varios objetivos, se comparan en funcion de su utilidad. El agente escogera la accion mas util",-1),R=(0,i._)("p",null,"Si existe incertidumbre, se habla de utilidad esperada, que es la suma ponderada de las utilidades de cada resultado segun su probabilidad:",-1),L=(0,i._)("p",null,"donde u es igual a la utilidad por p que es la probabilidad que ocurra mas el valor de las acciones subsiguientes",-1),I=(0,i.uE)('<h3>Agentes que aprenden</h3><p>Aprende a partir de la secuencia de percepciones y de las consecuencias de las acciones realizadas se compone de 4 elementos:</p><dl><dt>Elemento de Actuacion</dt><dd>un agente de los anteriores</dd><dt>Elemento de Aprendizaje</dt><dd>mejora al agente</dd><dt>Critica</dt><dd>recompensa o penalizacion</dd><dt>Generador de problemas</dt><dd>Incita a la exploracion</dd></dl><h2>Representacion del Entorno</h2><p>Estructura de datos para representar el entorno en el que habita el agente (estado, modelo, acciones, etc.) se pueden agrupar en los siguientes grupos</p><ul><li><em>Atomico:</em> sin estructura interna (dato simple). y se suele usar en busquedas, juegos, modelos ocultos de markov, procesos de decision de markov</li><li><em>Factorizado:</em> vector con pares atributo-valor. se suele ver en satisfaccion de restricciones, logica proposicional, planificacion, redes bayesianas</li><li><em>Estructurado:</em> objetos con atributos y relaciones con otros objetos (OOP). se usa en BD relacionales, logica del 1<sup>er</sup> orden razonamiento, aprendizaje, lenguaje natural.</li></ul><div class="importante">Cuanto mas expresiva es una representacion, menos espacio ocupa pero mas complejo es el razonamiento y el aprendizaje</div>',7);function O(e,a){const o=(0,i.up)("math-jax"),n=(0,i.Q2)("highlightjs");return(0,i.wg)(),(0,i.iD)("div",s,[r,(0,i.wy)(((0,i.wg)(),(0,i.iD)("pre",null,l)),[[n]]),(0,i.wy)(((0,i.wg)(),(0,i.iD)("pre",null,d)),[[n]]),u,p,m,b,g,(0,i.wy)(((0,i.wg)(),(0,i.iD)("pre",null,h)),[[n]]),(0,i.wy)(((0,i.wg)(),(0,i.iD)("pre",null,q)),[[n]]),w,A,(0,i.wy)(((0,i.wg)(),(0,i.iD)("pre",null,j)),[[n]]),(0,i.wy)(((0,i.wg)(),(0,i.iD)("pre",null,S)),[[n]]),P,x,D,z,C,_,R,L,(0,i.Wm)(o,{latex:"U=u_{1}p_{1}+u_{2}p_{2}+\\cdots +u_{n}p_{n}"}),I])}var M=o(3744);const B={},N=(0,M.Z)(B,[["render",O]]);var k=N},5021:function(e,a,o){o.r(a),o.d(a,{default:function(){return m}});var i=o(6252);const n={id:"cuerpo"},s=(0,i.uE)('<h1>Complejidad y Tratabilidad</h1><p>El factor mas predominante que delimita lo que se puede resolver en un tiempo razonable de lo que no lo es suele ser el <em class="enfasis">algoritmo</em> elegido para resolver el problema y no la potencia de calculo.</p><p>El programador es responsable de usar los recursos del computador de la forma mas eficiente posible.</p><h2>Factores que influyen en la eficiencia del algoritmo</h2><dl><dt>El tamaño</dt><dd>hace referencia a la cantidad de datos de entrada</dd><dt>El contenido</dt><dd>Hace referencia a que datos estamos tratando estos pueden hacer oscilar la eficiencia del algoritmo entre el valor minimo y el valor maximo</dd><dt>El computador</dt><dd>Se refiere al procesamiento que puede usar el algoritmo.</dd></dl><h2>Casos al momento de analizar un algoritmo</h2><dl><dt>Mejor caso</dt><dd>analisis con los datos de entrada que hacen que el algoritmo tarde menos tiempo. aporta el limite minimo.</dd><dt>Peor caso</dt><dd>analisis con los datos de entrada que hacen que el algoritmo tarde mas tiempo. aporta el limite maximo y es el mas critico y mas importante.</dd><dt>Caso Promedio</dt><dd>analisis con los datos de entrada que se dan con mayor frecuencia. es mas realista pero es el mas complejo de calcular analiticamente aunque se puede aproximar experimentalmente.</dd></dl><h2>Criterio Asintotico</h2><p><em class="enfasis">Se ignorara al computador y al compilador.</em></p><ul><li>Analisis independiente de la maquina y el lenguaje. un programa tan solo es una implementacion concreta de un algoritmo.</li><li>Para tamaños suficientemente grandes, el tiempo de ejecucion depende mas del algoritmo que de la maquina o el lenguaje. Diferentes implementaciones solo se diferencian en una constante multiplicativa.</li><li>El analisis se realizara tanto en tiempo como en espacio(memoria utilizada.) son contrapuestos</li></ul><h2>Complejidad Asintotica</h2><p>tambien llamadas <em class="enfasis">Notacion asintotica, analisis asintotico o criterio Asintotico</em></p><p>Asignar un orden de complejidad a cada algoritmo solo segun el tamaño de su problema(tamaño de los datos de entrada).</p><p>Ejemplos: longitud de un vector, cantidad de elementos de una coleccion, longitud de un fichero, dimensiones de una matriz, magnitud de los numeros, etc.</p><h2>Calculo de la eficiencia</h2><p>A cada instruccion de un algoritmo se le asigna un coste.</p><dl><dt>Instruccion basica</dt><dd>Que no depende del ta del problema(asignacion, I/O,etc.): Coste costante</dd><dt>Secuencia de instrucciones</dt><dd>el coste sera el de la instruccion conste maximo (alternativa: suma).</dd><dt>Condicionales</dt><dd>de las dos opciones, la que tenga mayor coste.</dd><dt>Iteraciones</dt><dd>Se multiplica el numero maximo de iteraciones por el coste del bucle.</dd><dt>Instruccion critica</dt><dd>Instruccion que mas veces se repite dentro de un programa, para tamaños de programa suficientemente grandes, el resto del programa perdera importancia frente al coste de repetir la instruccion critica, por muy elemental que sea.</dd></dl>',17),r=(0,i.uE)('<code class="plaintext"><em class="clave">funcion</em> <em class="cambiar">EJEMPLO</em>(problema) <em class="clave">devuelve</em> resultado <em class="comentario">#-------------f(n<sup>2</sup>)------------------</em>\r\n\r\n    variable=valor <em class="comentario"># f(1)  </em>\r\n    resultado=invocar-metodo(problema) <em class="comentario"># f(n)</em>\r\n    si resultado == 0 entonces <em class="comentario">#----------f(n<sup>2</sup>)------</em>\r\n        mostrar-error-pantalla() <em class="comentario"># f(1)</em>\r\n    si no\r\n        por cada elemento en resultado <em class="comentario">#------f(n*n) = f(n<sup>2</sup>)</em>\r\n            otra = metodo(elemento) <em class="comentario"># f(1)</em>\r\n            variable=variable+1 <em class="comentario"># f(1)</em>\r\n            si otra &gt; variable entonces <em class="comentario">#------f(n)</em>\r\n                mostrar-aviso-pantalla() <em class="comentario"># f(1)</em>\r\n            si no\r\n                otro-metodo(otra) <em class="comentario"># f(n)</em>\r\n\r\n    <em class="clave">devolver</em> resultado\r\n    </code>',1),t=[r],l=(0,i.uE)('<h3>Matices</h3><ul><li>Con constantes multiplicativas muy grandes, para problemas con tamaños pequeños, es mejor usar algoritmos mas ineficientes.</li><li>Para funciones que se van a usar pocas veces, no importa usar algoritmos mas ineficientes si son mas rapidos de desarrollar y mantener</li><li>la ganancia en tiempo suele ser a costa del uso del espacio ocupado. la memoria es un recurso muy limitante, mas que el tiempo, luego hay que buscar un equilibrio.</li></ul><h3>Ordenes de complejidad</h3><p>De menor coste al mayor coste.</p><table class="table table-dark table-striped table-hover"><tr><th scope="col">Codigo</th><th scope="col">Descripccion</th></tr><tr><td scope="row">O(1)</td><td scope="row">Orden Constante</td></tr><tr><td scope="row">O(log(n))</td><td scope="row">Orden Logaritmico</td></tr><tr><td scope="row">O(n)</td><td scope="row">Orden Lineal</td></tr><tr><td scope="row">O(n)</td><td scope="row">Orden Lineal</td></tr><tr><td scope="row">O(n*log(n))</td><td scope="row">Orden N-Logaritmico</td></tr><tr><td scope="row">O(n<sup>2</sup>)</td><td scope="row">Orden Cuadratico</td></tr><tr><td scope="row">O(n<sup>a</sup>)</td><td scope="row">Orden polinomico</td></tr><tr><td scope="row">O(a<sup>n</sup>)</td><td scope="row">Orden Exponencial</td></tr><tr><td scope="row">O(a!)</td><td scope="row">Orden Factorial</td></tr><tr><td scope="row">O(n<sup>n</sup>)</td><td scope="row">Orden Potencial-Exponencial</td></tr></table><h3>Tratabilidad</h3><dl><dt>Problemas Indecidibles</dt><dd>Son los que no poseen un algoritmo. No es que no se conozca aun, sino que no existe algoritmo</dd><dt>Problemas Decidibles</dt><dd>Posee algoritmos, por lo que se pueden resolver mediante un programa (aunque aun no lo conozcamos) <ul><li><em>Problemas Tratables (clase P)</em> Orden Polinomico o inferior</li><li><em>Problemas intratables (clase NP)</em> Orden exponencial o superior</li><li><em>Clase NP-Completa (NP-Duro)</em> son de la clase NP pero no de la clase P. (No se conoce solucion polinomica).</li></ul></dd></dl>',7);function c(e,a){const o=(0,i.Q2)("highlightjs");return(0,i.wg)(),(0,i.iD)("div",n,[s,(0,i.wy)(((0,i.wg)(),(0,i.iD)("pre",null,t)),[[o]]),l])}var d=o(3744);const u={},p=(0,d.Z)(u,[["render",c]]);var m=p},8282:function(e,a,o){o.r(a),o.d(a,{default:function(){return u}});var i=o(6252);const n={id:"cuerpo"},s=(0,i.uE)("<h1>Lenguajes de Programacion</h1><h2>Tipos de Lenguajes</h2><dl><dt>Imperativos</dt><dd>Se dan una serie de instrucciones indicando COMO hacer lo que queremos</dd><dt>Declarativos</dt><dd>Se basan en el lenguaje natural y teniendo una base de conocimiento de fondo el lenguaje da un resultado lo que &quot;quiero HACER&quot;</dd></dl><h3>Lenguajes Imperativos</h3><p>Estan enfocados en el hardware por lo tanto los primeros lenguajes estan en codigo maquina</p><ul><li><em>Ensamblador:</em> estan hechos en codigo maquina, son los primeros lenguajes imperativos su codigo es complejo y era dificil de integrar a otra maquina ya que estaban hechos a la medida. (lenguajes de bajo nivel)</li><li><em>Estructurados:</em> Se hace una extraccion y estan a la mitad del lenguaje natural. ya no depende de la maquina ya que se traduce el lenguaje a codigo maquina usando un compilador algunos lenguajes que se encuentran aqui son: C, Basic, Pascal, ADA, Cobol entre otros. se crean algunos paradismas que son Secuencia (se ejecuta en orden),Seleccion(condicionales y modificadores de flujo) y Iteradores (bucles), Datos Complejos(listas, arboles, registros), Funciones (crea un bloque de codigo para reutilizarlo) y Modulos(librerias). y son un lenguajes de alto nivel</li><li><em>Programacion Orientada a Objetos:</em> Aparecen nuevos conceptos como Objetos,Clases, Atrubutos, Metodos, Interfaces, Mensajes, Eventos, Encapsulado(Publico, Privado y Protegido), Herencia( Multiple, Polimorfismo, Clases Abstractas) algunos de los lenguajes que usan este paradigma son: C++, C#, JAVA, JavaScript, Python, Ruby</li></ul><h3>Lenguajes Declarativos</h3><ul><li><em>Funcionales(matematicas)</em></li><ul><li>Listas, Funciones(matematicas), Lambda y recursividad</li><li>Lisp, Scheme, Haskell</li></ul><li><em>Logicos (logicas de 1<sup>er</sup> Orden y Difusas</em></li><ul><li>Hechos, Reglas, Inferencias, Deducciones, Inducciones</li><li>Programas: Prolog, CLIPS, Fuzzy CLIPS</li></ul><li><em>Proposito Especifico</em></li><ul><li>Estadisticas: R</li><li>Bases de Datos: SQL</li><li>WEB: HTML, CSS</li></ul></ul>",8),r=[s];function t(e,a){return(0,i.wg)(),(0,i.iD)("div",n,r)}var l=o(3744);const c={},d=(0,l.Z)(c,[["render",t]]);var u=d},7032:function(e,a,o){o.r(a),o.d(a,{default:function(){return u}});var i=o(6252);const n={id:"cuerpo"},s=(0,i.uE)('<h1>Presentacion</h1><p>Para poder realizar una buena inteligencia artificial se debe tener varias areas aprendidas las cuales son como requisito para entender los algoritmos de estas.</p><ul><li>Matematicas y Fisica</li><li>Informatica, redes e Internet</li><li>Programación, Bases de Datos y RegEx</li><li>Ingles</li></ul><h2>Inteligencia Artificial</h2><p>Ya que no existe una definicion formal para inteligencia es muy dificil dar una definicion de inteligencia artificial. y podemos encontrar en el libro de inteligencia artificial un enfoque moderno. que pueden existir cuatro enfoques que permiten responder a esta pregunta.</p><table class="table table-dark table-striped table-hover"><tr><th scope="col"></th><th scope="col">Humano</th><th scope="col">Racional</th></tr><tr><td scope="row">Pensamiento(Interno)</td><td scope="row">TEST DE TURING<br>Pensamiento como humanos</td><td scope="row">LOGICA<br>Pensar Racionalmente</td></tr><tr><td scope="row">Comportamiento (Externo)</td><td scope="row">REDES NEURONALES<br>Comportarse como humanos</td><td scope="row">AGENTES RACIONALES<br>Comportarse racionalmente</td></tr></table><h3>Test de turing:</h3><p>Evalua que la IA pueda responder igual a un humano ya que el que evalua no puede decir si es una maquina o una persona la que esta respondiendo sus preguntas aunque no se suele crear maquinas que pasen el test porque es mas importante entender como funciona algo y no imitarlo, no se necesita imitar algo que vuele sino entender como es que vuelan para poder lograrlo. <q cite="inteligencia artificial un enfoque moderno">construccion de maquinas que vuelen como palomas de forma que puedan incluso confundir a otras palomas.</q></p><h3>Redes Neuronales</h3><p>Este enfoque lo que intenta es comparar el comportamiento que existe al presentarse una situacion dada, y es evaluada a nivel psicologico y tiempos de reaccion similares a un humano, se usa el tema de redes neuronales ya que estas han dado buenos resultados en el comportamiento, la mejor opcion.</p><h3>Logica</h3><p>La manera correcta de pensar, siempre se llega a conclusiones correctas si se parte de premisas correctas. aun tiene dos grandes problemas que el mundo no se puede representar 100% en forma logica y que se necesita mucho poder computacional para solucionar problemas de una gran cantidad de datos.</p><h3>Agentes Racionales</h3><p>Un agente racional es aquel que actua con la intencion de alcanzar el mejor resultado posible en un tiempo optimo.</p><h2>Maquinas beneficiosas</h2><p>Es necesario tener presente que cada vez es mas dificil establecer el objetivo que queremos que cumpla la IA ya que al permitir que interactuen con el mundo real debemos permitir que la IA asuma un riesgo en actuar ejemplo la escena que nos plantea yo robot donde la unica forma de proteger a los humanos es encerandolos para que no sufran daño, igual pasa con los peligros de conducir, en si en cada proceso que se le deje tomar la decision a una maquina se comienza a tener el riesgo de lo que interpreta la maquina que es lo que queremos a lo que realmente queremos este problema se conoce como &quot;problema de alineacion de valores&quot; <q>No queremos maquinas que sean inteligentes en el sentido de perseguir sus objetivos, queremos que persigan nuestros objetivos</q></p><h2>Fundamentos de la IA</h2><p>las siguientes ramas han aportado en alguna medida al desarrollo de la inteligencia artificial.</p><ul><li>Filosofia <ul><li>¿como se genera la inteligencia mental a partir de un cerebro fisico?</li><li>¿De donde viene el conocimiento?</li><li>¿como se pasa del conocimiento a la accion?</li></ul></li><li>Matematicas <ul><li>¿que reglas formales son las adecuadas para obtener conclusiones validas?</li><li>¿que se puede computar?</li><li>¿como razonamos con informacion incierta?</li></ul></li><li>Economia <ul><li>¿como se debe llevar a cabo el proceso de toma de decisiones para maximizar el rendimiento?</li><li>¿como se debe llevar a cabo acciones cuando otros no colaboren?</li><li>¿como se deb levar a cabo acciones cuando los resultados se obtienen en un futuro lejano?</li></ul></li><li>Neurociencia <ul><li>¿como procesa informacion el cerebro?</li></ul></li><li> Psicologia <ul><li>¿como piensa y actuan los humanos y los animales?</li></ul></li><li> Ingenieria computacional <ul><li>¿como se puede construir un computador eficiente?</li></ul></li><li> Teoria de control y cibernetica <ul><li>¿como pueden los artefactos operar bajo su propio control?</li></ul></li><li> Lingüistica <ul><li>¿como esta relacionado el lenguaje con el pensamiento?</li></ul></li></ul><p>para la construccion de inteligencia artificial se ha basado en dos grandes enfoques el <em class="enfasis">Bioinspirados</em> que uno de sus ejemplos son redes neuronales y algoritmos geneticos. y <em class="enfasis">Matematicos</em> como grafos y busqueda, simbolicos: logica y Sistemas basados en Conocimientos(SBC), probabilisticos. </p><h2>Areas de la IA</h2><ul><li>Busquedas</li><li>Representacion del conocimiento: simbolico, conexionista, mixto</li><li>Razonamiento: inductivo, deductivo, abductivo, analogo</li><li>Tratamiento de la incertidumbre</li><li>Planificacion</li><li>Toma de Decisiones</li><li>Aprendizaje: supervisado, No supervisado, por refuerzo.</li></ul><h2>Aplicaciones de la IA</h2><ul><li>Resolucion Automatica de problemas</li><li>Juegos</li><li>Mineria de Datos</li><li>Diagnostico</li><li>Prediccion</li><li>Procesamiento del lenguaje Natural</li><li>Percepcion</li><li>Robotica</li></ul>',24),r=[s];function t(e,a){return(0,i.wg)(),(0,i.iD)("div",n,r)}var l=o(3744);const c={},d=(0,l.Z)(c,[["render",t]]);var u=d},8039:function(e,a,o){o.r(a),o.d(a,{default:function(){return j}});var i=o(6252),n=o(3649);const s={id:"cuerpo"},r=(0,i._)("h1",null,"Razonamiento y Aprendizaje",-1),t=(0,i._)("p",null,"algunos algoritmos que se pueden encontran en la programacion son los que manejan datos numericos ejemplo el tamaño de las hojas de una planta entre este grupo tenemos los conexionistas (grafos y redes) que se pueden representar en un formato grafico y los que manejan datos simbolicos ejemplo el color de las hojas de una planta y son usados en la logica como en nivel textual y el lenguaje formal.",-1),l=(0,i._)("h2",null,"Conecionistas",-1),c=(0,i._)("p",null,"El siguiente ejemplo es un grafo etiquetado y dirigido recordando que esto es una estructura.",-1),d=(0,i._)("img",{src:n,alt:"ejemplo de un grafo"},null,-1),u=(0,i._)("h2",null,"Representacion Simbolica",-1),p=(0,i._)("h3",null,"Reglas",-1),m=(0,i._)("p",null,"En la logica tenemos que se representa por reglas, que son compuestas de antecedentes y Consecuente un ejemplo es el siguiente A es el padre de B y B es el padre de C si entonces A es el abuelo de C",-1),b=(0,i._)("h3",null,"Hechos",-1),g=(0,i._)("p",null,"los hechos son cosas de la realidad que son representadas con las reglas",-1),f=(0,i._)("h2",null,"Tipos de Razonamiento",-1),h=(0,i._)("p",null,"Existen cuatro tipos de razonamiento la cual se dan teniendo algunos datos ya sean los hechos, reglas o las consecuencias",-1),v=(0,i.uE)('<table class="table table-dark table-striped table-hover"><tr><th scope="col"></th><th scope="col">Hechos</th><th scope="col">Reglas</th><th scope="col">Consecuencias</th></tr><tr><td scope="row">Deductivo</td><td scope="row">Se tiene </td><td scope="row">Se tiene </td><td scope="row">Se obtiene</td></tr><tr><td scope="row">Inductivo</td><td scope="row">Se tiene</td><td scope="row">Se obtiene</td><td scope="row">Se tiene</td></tr><tr><td scope="row">Abductivo</td><td scope="row">Se obtiene</td><td scope="row">Se tiene</td><td scope="row">Se tiene</td></tr><tr><td scope="row">Analogico (se basa en datos anteriores como categorizar los animales perro, gatos etc.)</td><td scope="row">Se tiene</td><td scope="row">No se tiene</td><td scope="row">Se obtiene</td></tr></table><h2>Tipos de Aprendizaje</h2><p>Si los ejemplos (instancias) con los que se va a realizar el aprendizaje tiene o no una etiqueta con la clase a la que pertenecen</p><ul><li><em>Supervisado</em> ejemplos etiquetados</li><li><em>No supervidado</em> ejemplos NO etiquetados</li><li><em>Por Refuerzo (recompensa) </em>etiqueta a posteriori </li></ul>',4);function q(e,a){const o=(0,i.up)("math-jax");return(0,i.wg)(),(0,i.iD)("div",s,[r,t,l,c,d,u,p,m,(0,i.Wm)(o,{latex:"padre(A,B) padre(B,C) \\rightarrow abuelo(A,C)"}),b,g,(0,i.Wm)(o,{latex:"padre(Antonio, Bernardo) padre(Bernardo,Carlos) \\rightarrow abuelo(Antonio,Carlos)"}),f,h,(0,i.Wm)(o,{latex:"hechos + reglas \\rightarrow consecuencias"}),v])}var w=o(3744);const A={},y=(0,w.Z)(A,[["render",q]]);var j=y},7329:function(e,a,o){o.r(a),o.d(a,{default:function(){return p}});var i=o(6252),n=o(5338);const s={id:"cuerpo"},r=(0,i.uE)('<h1>Expresiones Regulares</h1><p>Son un conjunto de caracteres que generan un patron. que permite realizar busquedas de texto. validando si cumple el patron creado. cada expresion tiene un automata finito.</p><h2>Automata finito</h2><p>El Automata finito es un modelo computacional que tiene una entrada de datos y su correspondiente salida, pasando por varios estados dependiendo el patron al que deseamos encontrar ejemplo si se crea la expresion &quot;abc&quot; el automata finito sera el siguiente. donde solo se cumple cuando se pasa por todos los estados de a pasa a b y de b pasa a c y como no tiene otras condiciones solo funcionaria con esas tres letra y ignararia cualquier otro caracter que este despues del ultimo estado que es c</p><img src="'+n+'"><h2>Anchors o limitadores</h2><table class="table table-dark table-striped table-hover"><tr><th scope="col">Simbolo</th><th scope="col">Descripcion</th></tr><tr><td scope="row">^</td><td scope="row">Este simbolo nos permite indicarle que el texto debe iniciar con, algo a tener encuenta es que funciona con el inicio de un documento o el inicio de una linea o el inicio de un string.se puede usar de la siguiente manera. <br><em class="enfasis">^Git</em><br>Se puede sacar con <kbd>alt</kbd>+<kbd>94</kbd></td></tr><tr><td scope="row">\\A</td><td scope="row">Este simbolo nos permite indicarle que el texto debe iniciar con, algo a tener encuenta es que funciona con el inicio de un documento o el inicio de una linea o el inicio de un string.se puede usar de la siguiente manera. <br><em class="enfasis">\\AGit</em></td></tr><tr><td scope="row">$</td><td scope="row">Este simbolo nos permite indicarle que el texto debe terminar con, algo a tener encuenta es que funciona con el final de un documento o el final de una linea o el final de un string.se puede usar de la siguiente manera. <br><em class="enfasis">Git$</em><br>Se puede sacar con <kbd>alt</kbd>+<kbd>36</kbd></td></tr><tr><td scope="row">\\Z</td><td scope="row">Este simbolo nos permite indicarle que el texto debe terminar con, algo a tener encuenta es que funciona con el final de un documento o el final de una linea o el final de un string.se puede usar de la siguiente manera. <br><em class="enfasis">Git\\Z</em></td></tr><tr><td scope="row">\\b</td><td scope="row">Nos permitr indicar que buscamos un limite de palabra <br>Se puede usar de la siguiente manera <br> <em class="enfasis">Git\\b</em><br>la barra vertical se puede sacar con <kbd>alt</kbd>+<kbd>92</kbd></td></tr><tr><td scope="row">\\B</td><td scope="row">Nos permitr indicar que buscamos cualquier caracter que no sea un limite de palabra <br>Se puede usar de la siguiente manera <br> <em class="enfasis">Git\\B</em><br>la barra vertical se puede sacar con <kbd>alt</kbd>+<kbd>92</kbd></td></tr><tr><td scope="row">\\&lt;</td><td scope="row">Nos permitr indicar que buscamos una palabra que inicie con un caracter especifico se puede usar <br> <em class="enfasis">\\&lt;Git</em></td></tr><tr><td scope="row">\\&gt;</td><td scope="row">Nos permitr indicar que buscamos una palabra que finalice con un caracter especifico se puede usar <br> <em class="enfasis">Git\\&gt;</em></td></tr></table><h2>Quantifiers o Cuantificadores</h2><table class="table table-dark table-striped table-hover"><tr><th scope="col">Simbolo</th><th scope="col">Descripcion</th></tr><tr><td scope="row">*</td><td scope="row">Cero o mas veces. se usa de la siguiente manera<br><em class="enfasis">a*</em></td></tr><tr><td scope="row">+</td><td scope="row">uno o mas veces. se usa de la siguiente manera<br><em class="enfasis">a+</em></td></tr><tr><td scope="row">?</td><td scope="row">cero o una vez<br><em class="enfasis">a?</em></td></tr><tr><td scope="row">{#}</td><td scope="row">Exactamente la cantidad escrita entre los corchetes<br><em class="enfasis">a{3}</em></td></tr><tr><td scope="row">{#,}</td><td scope="row">la cantidad escrita o mas veces<br><em class="enfasis">a{3,}</em></td></tr><tr><td scope="row">{#,#}</td><td scope="row">desde una cantidad minima hasta una cantidad maxima<br><em class="enfasis">a{3,6}</em></td></tr></table><h2>manera no codiciosa</h2><p>Las expresiones regulares trabajan de forma codiciosa opteniendo la mayor cantidad de texto que cumpla la condicion, suelen venir despues de un asterisco o del simbolo + para cambiar este comportamiento se tiene que colocar el simbolo <em class="enfasis">?</em> despues de estos simbolos quedando de la siguiente manera <em class="enfasis">a*?</em></p><h2>charater classes o Clases de caracteres</h2><table class="table table-dark table-striped table-hover"><tr><th scope="col">Simbolo</th><th scope="col">Descripcion</th></tr><tr><td scope="row">\\c</td><td scope="row">caracter de control<br> se usa <em class="enfasis">\\c</em></td></tr><tr><td scope="row">\\s</td><td scope="row">caracter de espacio puede ser tabulador, espacio <br> se usa <em class="enfasis">\\s</em></td></tr><tr><td scope="row">\\S</td><td scope="row">caracter que indica cualquier caracter diferentes a los de espacio <br> se usa <em class="enfasis">\\S</em></td></tr><tr><td scope="row">\\d</td><td scope="row">caracter que indica cualquier caracter numerico <br> se usa <em class="enfasis">\\d</em></td></tr><tr><td scope="row">\\D</td><td scope="row">caracter que indica que sea cualquier caracter No numerico <br> se usa <em class="enfasis">\\D</em></td></tr><tr><td scope="row">\\w</td><td scope="row">caracter que indica que buscamos un caracter de palabra los cuales estan compuestos por numeros, letras o _ <br> se usa <em class="enfasis">\\w</em></td></tr><tr><td scope="row">\\W</td><td scope="row">caracter que indica que No buscamos un caracter de palabra lo que indica cualquier caracter que no sean numeros, letras o _ <br> se usa <em class="enfasis">\\W</em></td></tr><tr><td scope="row">\\x</td><td scope="row">caracter para buscar un caracter de numeros hexadecimales<br> se usa <em class="enfasis">\\x</em></td></tr><tr><td scope="row">\\O</td><td scope="row">caracter para buscar un caracter de numeros Octaldecimal<br> se usa <em class="enfasis">\\O</em></td></tr></table><h2>assertions o Aserciones</h2><table class="table table-dark table-striped table-hover"><tr><th scope="col">Simbolo</th><th scope="col">Descripcion</th></tr><tr><td scope="row">?=</td><td scope="row">nos permite condicionar la expresion que estamos buscando que contenga algo a continuacion <br> se usa <em class="enfasis">Vino(?=\\s\\w+)</em></td></tr><tr><td scope="row">?!</td><td scope="row">nos permite condicionar la expresion que estamos buscando que no continue con <br> se usa <em class="enfasis">Java\\s(?!8|9)</em></td></tr><tr><td scope="row">?&lt;=</td><td scope="row"></td></tr><tr><td scope="row">?!= or ?&lt;!</td><td scope="row"></td></tr><tr><td scope="row">?&gt;</td><td scope="row"></td></tr><tr><td scope="row">?()</td><td scope="row"></td></tr><tr><td scope="row">?()|</td><td scope="row"></td></tr><tr><td scope="row">?#</td><td scope="row"></td></tr></table><h2>conjuntos de caracteres y rangos</h2><table class="table table-dark table-striped table-hover"><tr><th scope="col">Simbolo</th><th scope="col">Descripcion</th></tr><tr><td scope="row">.</td><td scope="row">nos permite simbolizar cualquier caracter excepto nueva linea \\n <br> se usa <em class="enfasis">.</em></td></tr><tr><td scope="row">|</td><td scope="row">nos permite crear multiples secuencias de caracteres dandolo como &quot;o&quot;, entonces se expresa como &quot;a&quot; o &quot;b&quot; <br> se usa <em class="enfasis">ruben|dario</em></td></tr><tr><td scope="row">()</td><td scope="row">agrupa toda la secuencia que esta dentro de los parentesis<br> se usa <em class="enfasis">(ruben)</em></td></tr><tr><td scope="row">(?:)</td><td scope="row">no cuenta este grupo osea ignora el dato que se crea en este grupo <br> se usa <em class="enfasis">(?:regex)</em></td></tr><tr><td scope="row">[]</td><td scope="row">esto nos permite generar rangos o crear un grupo de caracteres que pueden aparecer <br>se usa <em class="enfasis">[a-zA-Z0-9]</em></td></tr><tr><td scope="row">[^.]</td><td scope="row">Este niega los caracteres que estan dentro del rango lo que indica que no puede ir ningun caracter que esta en ese rango <br>se usa <em class="enfasis">[^0-9]</em></td></tr></table><h2>remplazo con grupos</h2><p>Al colocar parentesis se crea grupos y se comienza a contar desde uno para poder usarlos se usa <em class="enfasis">$</em> o <em class="enfasis">\\$</em> con el respectivo numero del grupo.</p><table class="table table-dark table-striped table-hover"><tr><th scope="col">Simbolo</th><th scope="col">Descripcion</th></tr><tr><td scope="row">$</td><td scope="row">nos permite usar el string que coincide con los parametros de busqueda de un grupo espesifico<br>se usa <em class="enfasis">$1</em></td></tr><tr><td scope="row">$`</td><td scope="row">String Antes de la coincidencia</td></tr><tr><td scope="row">$&#39;</td><td scope="row">String despues de la coincidencia</td></tr><tr><td scope="row">$+</td><td scope="row">ultima coincidencia</td></tr><tr><td scope="row">$&amp;</td><td scope="row">Toda la coincidencia</td></tr></table><h2>Banderas</h2><table class="table table-dark table-striped table-hover"><tr><th scope="col">Simbolo</th><th scope="col">Descripcion</th></tr><tr><td scope="row">g</td><td scope="row">nos permite realizar la busqueda de manera global</td></tr><tr><td scope="row">i</td><td scope="row">nos permite realizar la busqueda ignorando si es mayuscula o minuscula</td></tr><tr><td scope="row">m</td><td scope="row">nos permite realizar la busqueda por multiples lineas en un string que este separaado por lineas</td></tr><tr><td scope="row">s</td><td scope="row">nos permite tratar un string como una sola linea</td></tr><tr><td scope="row">x</td><td scope="row">permite comentarios y espacios en blanco en patron</td></tr><tr><td scope="row">e</td><td scope="row">Evaluar el reemplazo</td></tr><tr><td scope="row">U</td><td scope="row">patron no codicioso</td></tr></table><h2>Posix</h2><table class="table table-dark table-striped table-hover"><tr><th scope="col">Simbolo</th><th scope="col">Descripcion</th></tr><tr><td scope="row">[:upper:]</td><td scope="row">Mayusculas</td></tr><tr><td scope="row">[:lower:]</td><td scope="row">Minusculas</td></tr><tr><td scope="row">[:alpha:]</td><td scope="row">Todas las letras</td></tr><tr><td scope="row">[:alnum:]</td><td scope="row">alfanumericos</td></tr><tr><td scope="row">[:digit:]</td><td scope="row">numeros</td></tr><tr><td scope="row">[:xdigit:]</td><td scope="row">numeros hexadecimales</td></tr><tr><td scope="row">[:punct:]</td><td scope="row">puntuacion</td></tr><tr><td scope="row">[:blank:]</td><td scope="row">espacio y tabulador</td></tr><tr><td scope="row">[:space:]</td><td scope="row">espacio</td></tr><tr><td scope="row">[:cntrl:]</td><td scope="row">caracteres de control</td></tr><tr><td scope="row">[:graph:]</td><td scope="row">caracteres impresos</td></tr><tr><td scope="row">[:print:]</td><td scope="row">caracteres impresos y espacios</td></tr><tr><td scope="row">[:word:]</td><td scope="row">digitos, letras y underscore</td></tr></table>',24),t=[r];function l(e,a){return(0,i.wg)(),(0,i.iD)("div",s,t)}var c=o(3744);const d={},u=(0,c.Z)(d,[["render",l]]);var p=u},1708:function(e,a,o){o.r(a),o.d(a,{default:function(){return u}});var i=o(6252);const n={id:"cuerpo"},s=(0,i.uE)("<h1>Logica</h1><h2>Logica Proposicional</h2><ul><li>Sintaxis y semantica: tablas de verdad</li><li>Base de conocimiento</li><li>Inferencia Logica Proposicional</li><li>Equivalencia, Validez y Satisfacibilidad</li><li>Resolucion y forma Normal Conjuntiva</li><li>Encadenamiento: Hacia Delante y Atras</li><li>Backtracking</li><li>Algoritmos de Busqueda Local</li></ul><h2>Logica de 1<sup>er</sup> orden</h2><ul><li>sintaxis y semantica: Cuantificadores</li><li>Reglas de Diagnostico y causales</li><li>Ingenieria del conocimiento</li><li>Inferencia Logica: Unificacion</li><li>Encadenamiento: Hacia Delante y Atras</li><li>Programacion Logica: prolog y CLIPS</li><li>Resolucion: Skolem</li><li>Agentes Logicos</li></ul><h2>Otras Logicas</h2><ul><li>Logica de orden superior</li><li>Logica modal</li><li>Logica Temporal</li><li>Logica no Monotonica</li><li>Logica por Defecto</li><li>Logica Difusa <ul><li>Conjuntos difusos</li><li>Inferencia Difusa</li><li>Fuzzy CLIPS</li></ul></li></ul><h2>Representar el Conocimiento</h2><ul><li>Ingenieria del conocimiento: ontologias</li><li>Taxonomias: Categorias y Objetos</li><li>Acciones, Situaciones y eventos: Marcos</li><li>Eventos y Objetos mentales: creencias</li><li>Reglas, redes Semanticas y Logica Descriptiva</li><li>Razonomaniento por Defecto y No Monotonica</li><li>Incertidumbre y Factores de Certeza</li><li>Sistemas Expertos</li><li>Modelo Probabilista Racional</li></ul><h2>Planificacion</h2><ul><li>Algoritmos de planificacion: Strips y ADL</li><li>Espacio de Estados</li><li>Planificacion de orden parcial</li><li>Grafos de planificacion: Graphpl</li><li>Planificacion logica proposicional: Satplan</li><li>Redes jerarquicas de tareas</li><li>Panificacion condicional</li><li>Vigilancia de Ejecucion y Replanificacion</li><li>Planificacion continua y multiagente</li></ul><h2>Aprendizaje Inductivo</h2><ul><li>Tipos de Razonamiento y Aprendizaje</li><li>Arboles de Decision: ID3</li><li>Arboles de regresion: M5</li><li>Conjuntos de Hipotesis: Boosting</li><li>Listas de Decision: k-DL y K-DT</li><li>Mejor Hipotesis Actual</li><li>Espacio de Versiones y A<sup>Q</sup></li><li>Explicaciones e Informacion Relevante</li><li>Programacion Logica Inductiva: FOIL</li></ul><h2>Tratamiento Logico del Lenguaje</h2><ul><li>Gramaricas: Jerarquia de chomsky</li><li>Analisis Lexico</li><li>Analisis Sintactico</li><li>Analisis Semantico</li><li>Gramatica Causal Definida</li><li>Ambigüedad</li><li>Induccion Gramatical</li></ul>",15),r=[s];function t(e,a){return(0,i.wg)(),(0,i.iD)("div",n,r)}var l=o(3744);const c={},d=(0,l.Z)(c,[["render",t]]);var u=d},1310:function(e,a,o){o.r(a),o.d(a,{default:function(){return u}});var i=o(6252);const n={id:"cuerpo"},s=(0,i.uE)("<h1>Probabilidad</h1><h2>Conocimientos basicos</h2><ul><li>Incertidumbre</li><li>Probabilidad a priori</li><li>Probabilidad condicionada y normalizacion</li><li>Distribucion de probabilidad</li><li>Independencia Condicional</li><li>Regla de Bayes</li></ul><h2>Razonamiento Probabilistico</h2><ul><li>red bayesiana</li><li>regla de la cadena</li><li>manto de Markov</li><li>inferencia por enumeracion</li><li>Eliminacion de variables</li><li>Muestreo Directo y por Rechazo</li><li>Ponderacion de verosimilitud</li><li>Monte Carlo para Cadenas de Markov</li></ul><h2>Razonamiento Probabilistico en el tiempo</h2><ul><li>Procesos Estacionarios</li><li>Hipotesis de Markov: Procesos de Markov</li><li>Filtrado, Prediccion, Suavizado y Explicacion</li><li>Algoritmo Hacia Delante-Atras</li><li>Modelos Ocultos de Markov</li><li>Filtros de Kalman</li><li>Red Bayes. Dinamica: Filtrado de Particulas</li><li>Reconocimiento del Habla</li></ul><h2>Aprendizaje Probabilistico</h2><ul><li>Aprendizaje bayesiano</li><li>Naïve-Bayes</li><li>Algoritmo EM</li><li>Agrupamiento No Supervisado</li><li>Modelos de MArkov Ocultos</li><li>K-NN, K-medias y Clustering</li><li>Maquina de Vectores Soporte (Nucleo)</li><li>Aprendizaje profundo (Deep Learning)</li></ul><h2>Redes Neuronales</h2><ul><li>Computacion Neuronal</li><li>Funciones de Activacion</li><li>Perceptron, ADALINE y MANDALINE</li><li>Separabilidad Lineal</li><li>Redes Multicapa</li><li>Retropropagacion del Error</li><li>Mapas autoorganizados de Kohonen</li><li>Hamming, Hopfield, Hebb, Boltzmann, </li></ul><h2>Tratamiento Probabilistico del Lenguaje</h2><ul><li>Modelo Probabilistico del Lenguaje: Corpus</li><li>Gramaticas Probabilistico independiente del contexto</li><li>Gramaticas Probabilisticas Lexicalizadas</li><li>Recuperacion del Datos</li><li>Extraccion de Informacion</li><li>Traduccion Automatica Estadistica</li></ul><h2>Percepcion</h2><ul><li>Graficos por computador</li><li>Preprocesado: filtros</li><li>Deteccion de Aristas y Segmentacion</li><li>Texturas y Sombras</li><li>Reconocimiento de Objetos</li><li>Reconocimiento de Escritura</li><li>Etiquetados de Lineas</li><li>Movimiento</li></ul><h2>Robitica</h2><ul><li>Hardware Robotico: Sensores y Actuadores</li><li>Localizacion: Monte-Carlo</li><li>Generacion de mapas:SLAM</li><li>Movimiento: Espacio de configuracion</li><li>Cinematica Inversa</li><li>Incertidumbre</li><li>Dinamica y Control</li><li>Software Robotico</li></ul>",17),r=[s];function t(e,a){return(0,i.wg)(),(0,i.iD)("div",n,r)}var l=o(3744);const c={},d=(0,l.Z)(c,[["render",t]]);var u=d},3227:function(e,a,o){e.exports=o.p+"img/agente.228988ea.svg"},5338:function(e,a,o){e.exports=o.p+"img/automata_finito.9d45b857.svg"},3649:function(e,a,o){e.exports=o.p+"img/grafo1.08b21016.svg"}}]);
//# sourceMappingURL=about.7a242c7b.js.map